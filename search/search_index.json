{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Color \u00b6 Color is a Roblox Luau library for color management and manipulation, inspired by chroma.js . Installing \u00b6 The module is available in the library here if you want to install it using the Toolbox. You can also grab a release from GitHub and install it manually. If you know how to use Rojo , you can build the latest code from the development branch to get the newest features. Keep in mind that this is development code , and things can break or change quickly. The library has two parts: the Color module and the Gradient module. You can access them using [Module].Color and [Module].Gradient . local ColorLib = require (...) local Color = ColorLib . Color local Gradient = ColorLib . Gradient Conversions \u00b6 Colors can be constructed from different color types , including hex strings, HSB/L, and L*a*b*. You can use Color.from or Color.from[ColorType] (e.g. Color.fromHex ). There are also a few additional constructors: Color.new , which is equivalent to Color3.new Color.random for making random colors Color.gray for making greyscale colors Color.named for referencing CSS colors local pink = Color . fromHex ( \"#ff69b4\" ) local blue = Color . from ( \"HSB\" , 240 , 1 , 1 ) local yellow = Color . fromLab ( 0.97139 , - 0.21554 , 0.94478 ) local newYeller = Color . fromBrickColor ( BrickColor . new ( \"New Yeller\" )) local white = Color . new ( 1 , 1 , 1 ) -- or Color.gray(1) local hotpink = Color . named ( \"hotpink\" ) Likewise, you can also convert Colors to various color types, using Color.to or Color.to[ColorType] (e.g. Color.toHex ). You can also get the RGB components of a color using Color.components . local blue = Color . new ( 0 , 0 , 1 ) print ( blue : toHex ()) --> \"0000ff\" print ( blue : toHSB ()) --> 240, 1, 1 print ( blue : to ( \"Lab\" )) --> 0.32297, 0.79188, -1.07860 print ( blue : components ()) --> 0, 0, 1 Interpolation \u00b6 Color interpolation in RGB (e.g. using Color3.Lerp ) can result in grey or dark intermediate colors. This can be avoided by interpolating in a perceptually-uniform color space such as CIELAB or CIELUV, or by doing a \"linear RGB\" interpolation in XYZ. You can interpolate colors using Color.mix . local red = Color . named ( \"red\" ) local aqua = Color . named ( \"aqua\" ) red : mix ( aqua , 0.5 ) red : mix ( aqua , 0.5 , \"XYZ\" ) red : mix ( aqua , 0.5 , \"Lab\" ) red : mix ( aqua , 0.5 , \"Luv\" ) Here are images of what these interpolations look like: Miscellaneous \u00b6 The library includes some general-purpose manipulation functions: Color.invert for inverting colors Color.brighten and Color.darken for making colors brighter or darker Color.saturate and Color.desaturate for (de)saturating colors Color.blend for blending colors It also includes some functions which can be used for accessibility: Color.luminance for calculating the relative luminance of a color Color.contrast for calculating the contrast ratio between colors Color.bestContrastingColor for determining the color with the highest contrast ratio There are also functions that don't fall into a general category: Color.deltaE for calculating the difference between colors Color.harmonies for calculating harmonious colors Gradients \u00b6 Gradients are similar in construction and behaviour to ColorSequences. They can be used to generate intermediate colors or ColorSequences so that they can be used in places where they're required, such as ParticleEmitters or UIGradients. A Gradient can be constructed using an array of \"gradient keypoints\", which is just a dictionary with a Time and Color field, similar to the Time and Value fields of a ColorSequenceKeypoint . The constructor for this method is Gradient.new . local keypoints = { { Time = 0 , Color = Color . grey ( 0 )}, { Time = 0.25 , Color = Color . grey ( 0.5 )}, { Time = 1 , Color = Color . grey ( 1 )} } local gradient = Gradient . new ( keypoints ) You can also construct a Gradient with a list of Colors using Gradient.fromColors . This creates a gradient where the colors are equidistant from each other. local gradient = Gradient . fromColors ( Color . named ( \"red\" ), Color . named ( \"green\" ), Color . named ( \"blue\" ) ) Finally, the constructor Gradient.fromColorSequence creates a gradient from a ColorSequence. local cs = ColorSequence . new ( Color3 . new ( 0 , 0 , 0 ), Color3 . new ( 1 , 1 , 1 ) ) local gradient = Gradient . fromColorSequence ( cs ) Generating colors from a gradient is similar to mixing colors, using Gradient.color . If you need a list of colors, you can use Gradient.colors . If you need a ColorSequence, you can use Gradient.colorSequence . local gradient = Gradient . fromColors ( Color . named ( \"red\" ), Color . named ( \"green\" ), Color . named ( \"blue\" ) ) print ( gradient : color ( 0.6 , \"XYZ\" ): toHex ()) --> \"00737c\" print ( gradient : color ( 0.6 , \"HSB\" , \"Increasing\" ): to ( \"Hex\" )) --> \"00993d\" -- generates a list of 50 equidistant colors on the gradient gradient : colors ( 50 , \"XYZ\" ) -- generates a ColorSequence using the maximum number of keypoints (currently 20) gradient : colorSequence ( nil , \"XYZ\" )","title":"Home"},{"location":"#color","text":"Color is a Roblox Luau library for color management and manipulation, inspired by chroma.js .","title":"Color"},{"location":"#installing","text":"The module is available in the library here if you want to install it using the Toolbox. You can also grab a release from GitHub and install it manually. If you know how to use Rojo , you can build the latest code from the development branch to get the newest features. Keep in mind that this is development code , and things can break or change quickly. The library has two parts: the Color module and the Gradient module. You can access them using [Module].Color and [Module].Gradient . local ColorLib = require (...) local Color = ColorLib . Color local Gradient = ColorLib . Gradient","title":"Installing"},{"location":"#conversions","text":"Colors can be constructed from different color types , including hex strings, HSB/L, and L*a*b*. You can use Color.from or Color.from[ColorType] (e.g. Color.fromHex ). There are also a few additional constructors: Color.new , which is equivalent to Color3.new Color.random for making random colors Color.gray for making greyscale colors Color.named for referencing CSS colors local pink = Color . fromHex ( \"#ff69b4\" ) local blue = Color . from ( \"HSB\" , 240 , 1 , 1 ) local yellow = Color . fromLab ( 0.97139 , - 0.21554 , 0.94478 ) local newYeller = Color . fromBrickColor ( BrickColor . new ( \"New Yeller\" )) local white = Color . new ( 1 , 1 , 1 ) -- or Color.gray(1) local hotpink = Color . named ( \"hotpink\" ) Likewise, you can also convert Colors to various color types, using Color.to or Color.to[ColorType] (e.g. Color.toHex ). You can also get the RGB components of a color using Color.components . local blue = Color . new ( 0 , 0 , 1 ) print ( blue : toHex ()) --> \"0000ff\" print ( blue : toHSB ()) --> 240, 1, 1 print ( blue : to ( \"Lab\" )) --> 0.32297, 0.79188, -1.07860 print ( blue : components ()) --> 0, 0, 1","title":"Conversions"},{"location":"#interpolation","text":"Color interpolation in RGB (e.g. using Color3.Lerp ) can result in grey or dark intermediate colors. This can be avoided by interpolating in a perceptually-uniform color space such as CIELAB or CIELUV, or by doing a \"linear RGB\" interpolation in XYZ. You can interpolate colors using Color.mix . local red = Color . named ( \"red\" ) local aqua = Color . named ( \"aqua\" ) red : mix ( aqua , 0.5 ) red : mix ( aqua , 0.5 , \"XYZ\" ) red : mix ( aqua , 0.5 , \"Lab\" ) red : mix ( aqua , 0.5 , \"Luv\" ) Here are images of what these interpolations look like:","title":"Interpolation"},{"location":"#miscellaneous","text":"The library includes some general-purpose manipulation functions: Color.invert for inverting colors Color.brighten and Color.darken for making colors brighter or darker Color.saturate and Color.desaturate for (de)saturating colors Color.blend for blending colors It also includes some functions which can be used for accessibility: Color.luminance for calculating the relative luminance of a color Color.contrast for calculating the contrast ratio between colors Color.bestContrastingColor for determining the color with the highest contrast ratio There are also functions that don't fall into a general category: Color.deltaE for calculating the difference between colors Color.harmonies for calculating harmonious colors","title":"Miscellaneous"},{"location":"#gradients","text":"Gradients are similar in construction and behaviour to ColorSequences. They can be used to generate intermediate colors or ColorSequences so that they can be used in places where they're required, such as ParticleEmitters or UIGradients. A Gradient can be constructed using an array of \"gradient keypoints\", which is just a dictionary with a Time and Color field, similar to the Time and Value fields of a ColorSequenceKeypoint . The constructor for this method is Gradient.new . local keypoints = { { Time = 0 , Color = Color . grey ( 0 )}, { Time = 0.25 , Color = Color . grey ( 0.5 )}, { Time = 1 , Color = Color . grey ( 1 )} } local gradient = Gradient . new ( keypoints ) You can also construct a Gradient with a list of Colors using Gradient.fromColors . This creates a gradient where the colors are equidistant from each other. local gradient = Gradient . fromColors ( Color . named ( \"red\" ), Color . named ( \"green\" ), Color . named ( \"blue\" ) ) Finally, the constructor Gradient.fromColorSequence creates a gradient from a ColorSequence. local cs = ColorSequence . new ( Color3 . new ( 0 , 0 , 0 ), Color3 . new ( 1 , 1 , 1 ) ) local gradient = Gradient . fromColorSequence ( cs ) Generating colors from a gradient is similar to mixing colors, using Gradient.color . If you need a list of colors, you can use Gradient.colors . If you need a ColorSequence, you can use Gradient.colorSequence . local gradient = Gradient . fromColors ( Color . named ( \"red\" ), Color . named ( \"green\" ), Color . named ( \"blue\" ) ) print ( gradient : color ( 0.6 , \"XYZ\" ): toHex ()) --> \"00737c\" print ( gradient : color ( 0.6 , \"HSB\" , \"Increasing\" ): to ( \"Hex\" )) --> \"00993d\" -- generates a list of 50 equidistant colors on the gradient gradient : colors ( 50 , \"XYZ\" ) -- generates a ColorSequence using the maximum number of keypoints (currently 20) gradient : colorSequence ( nil , \"XYZ\" )","title":"Gradients"},{"location":"changelog/","text":"[0.2.2] - 2022-04-06 \u00b6 Changed \u00b6 Replaced the Raw hue adjustment option with Specified to match spec, however Raw will still work [0.2.1] - 2022-01-06 \u00b6 Changed \u00b6 The Gradient.new constructor now creates a copy of the input table instead of using the input table itself Gradient.Keypoints is now correctly frozen, where previously it was possible to modify the individual keypoints but not the keypoint list itself [0.2.0] - 2021-12-01 \u00b6 Added \u00b6 Added links in the documentation for further reading on various color types Added alternative from/to functions for the various color types e.g. Color.fromColor3(...) instead of Color.from(\"Color3\", ...) e.g. Color:toColor3() instead of Color:to(\"Color3\") Added Color.gray as a shortcut for creating achromatic colors Added Color.harmonies for generating color harmonies Added Color.deltaE for calculating color differences Added Color.named for referencing CSS colors Added the xyY color type Removed \u00b6 lRGB interpolation has been removed, since it can be done in XYZ Changed \u00b6 Refined code to reduce type-check warnings Documentation now reflects that the Hue component for some color types can be NaN Static functions in the documentation now have a badge Read-only properties in the documentation now have a badge The Color and Gradient modules of the library are now split apart You can access the modules using [Module].Color and [Module].Gradient Updated the allowed interpolations for Color.mix Color.isAColor should work for Colors from different versions of the library Color.components now allows you to obtain unclipped components Color.luminance compensates for the error from the equation provided in WCAG 2 Gradient.toColorSequence was renamed to Gradient.colorSequence [0.1.0] - 2021-11-09 \u00b6 Added \u00b6 Initial release","title":"Changelog"},{"location":"changelog/#022-2022-04-06","text":"","title":"[0.2.2] - 2022-04-06"},{"location":"changelog/#changed","text":"Replaced the Raw hue adjustment option with Specified to match spec, however Raw will still work","title":"Changed"},{"location":"changelog/#021-2022-01-06","text":"","title":"[0.2.1] - 2022-01-06"},{"location":"changelog/#changed_1","text":"The Gradient.new constructor now creates a copy of the input table instead of using the input table itself Gradient.Keypoints is now correctly frozen, where previously it was possible to modify the individual keypoints but not the keypoint list itself","title":"Changed"},{"location":"changelog/#020-2021-12-01","text":"","title":"[0.2.0] - 2021-12-01"},{"location":"changelog/#added","text":"Added links in the documentation for further reading on various color types Added alternative from/to functions for the various color types e.g. Color.fromColor3(...) instead of Color.from(\"Color3\", ...) e.g. Color:toColor3() instead of Color:to(\"Color3\") Added Color.gray as a shortcut for creating achromatic colors Added Color.harmonies for generating color harmonies Added Color.deltaE for calculating color differences Added Color.named for referencing CSS colors Added the xyY color type","title":"Added"},{"location":"changelog/#removed","text":"lRGB interpolation has been removed, since it can be done in XYZ","title":"Removed"},{"location":"changelog/#changed_2","text":"Refined code to reduce type-check warnings Documentation now reflects that the Hue component for some color types can be NaN Static functions in the documentation now have a badge Read-only properties in the documentation now have a badge The Color and Gradient modules of the library are now split apart You can access the modules using [Module].Color and [Module].Gradient Updated the allowed interpolations for Color.mix Color.isAColor should work for Colors from different versions of the library Color.components now allows you to obtain unclipped components Color.luminance compensates for the error from the equation provided in WCAG 2 Gradient.toColorSequence was renamed to Gradient.colorSequence","title":"Changed"},{"location":"changelog/#010-2021-11-09","text":"","title":"[0.1.0] - 2021-11-09"},{"location":"changelog/#added_1","text":"Initial release","title":"Added"},{"location":"api/color/","text":"Constructors \u00b6 Color.new \u00b6 Color.new(r: number, g: number, b: number): Color Standard Color constructor. Arguments should be in the range [0, 1], similar to Color3.new . Color.random \u00b6 Color.random(): Color Creates a Color with random RGB components. Color.gray \u00b6 Color.gray(scale: number): Color Creates an achromatic Color using the scale, which should be in the range [0, 1]. 0 corresponds to black, and 1 corresponds to white. Color.named \u00b6 Color.named(name: string): Color Creates a Color based on a named CSS color . Names are case-insensitive. Color.from \u00b6 Color.from(colorType: string, ...: any): Color Creates a Color from various color types. See the Color Types section for the list of available conversions and what arguments they require. Info You can also use an alternative constructor using Color.from[ColorType] (e.g. Color.fromColor3(...) instead of Color.from(\"Color3\", ...) ), except for the xyY color type. Properties \u00b6 Color.R \u00b6 Color.R: number The clipped red RGB channel of the color, in the range [0, 1]. Color.G \u00b6 Color.G: number The clipped green RGB channel of the color, in the range [0, 1]. Color.B \u00b6 Color.B: number The clipped blue RGB channel of the color, in the range [0, 1]. Functions \u00b6 Color.isAColor \u00b6 Color.isAColor(color: any): boolean Returns whether the provided value is a Color. Checks if the value is a table with the following properties: The table is frozen The table has keys R , G , B , __r , __g , __b with numeric values The table has a to function Color.isClipped \u00b6 Color.isClipped(color: Color): boolean Returns whether the Color's RGB components are clipped. Some conversions (e.g. XYZ to sRGB) may result in RGB components outside of the range [0, 1]. In this case, the components will be clipped to the range [0, 1]. print ( Color . new ( 1 , 1 , 1 ): isClipped ()) --> false print ( Color . new ( 2 , 2 , 2 ): isClipped ()) --> true Color.unclippedEq \u00b6 Color.unclippedEq(refColor: Color, testColor: Color): boolean Compares the unclipped components of the Colors for equality. print ( Color . new ( 1 , 1 , 1 ) == Color . new ( 2 , 2 , 2 )) --> true print ( Color . new ( 1 , 1 , 1 ): unclippedEq ( Color . new ( 2 , 2 , 2 ))) --> false Color.components \u00b6 Color.components(color: Color, unclipped: boolean? = false): (number, number, number) Returns the RGB components of the Color, either clipped or unclipped . You can also access the individual clipped components using Color.R , Color.G , and Color.B . Color.to \u00b6 Color.to(color: Color, colorType: string): ...any Converts a Color to different formats. See the Color Types section for the list of available conversions and what values they output. Info You can also use an alternative converter using Color.to[ColorType] , e.g. Color:toColor3() instead of Color:to(\"Color3\") . Color.invert \u00b6 Color.invert(color: Color): Color Returns a Color with inverted RGB components. Color.mix \u00b6 Color.mix(startColor: Color, endColor: Color, ratio: number, mode: string? = \"RGB\", hueAdjustment: string? = \"Shorter\"): Color Interpolates the start and end Colors in various color spaces. ratio should be in the range [0, 1]. Supported spaces are: RGB (default), CMYK , HSB (or HSV ), HWB , HSL , Lab , Luv , LChab (or LCh ), LChuv , xyY , and XYZ ( XYZ interpolation can be used for linear RGB interpolation). For color spaces with a hue component (e.g. HSB/L or LCh), there are different ways to interpolate the hue, and you can specify how it should be done by passing hueAdjustment : Shorter (default), Longer , Increasing , Decreasing , or Specified . These adjustments correspond to those specified in CSS Color Module Level 4 . Here are images of what the various interpolations look like, using red and aqua as example colors (with the default hue adjustment): Color.blend \u00b6 Color.blend(backgroundColor: Color, foregroundColor: Color, mode: string): Color Blends the background and foreground Colors in various modes. The available blending modes are: Normal , Multiply , Screen , Overlay , Darken , Lighten , ColorDodge , ColorBurn , HardLight , SoftLight , Difference , and Exclusion . The blending modes correspond to those specified in Compositing and Blending Level 1 . Color.deltaE \u00b6 Color.deltaE(refColor: Color, testColor: Color, kL: number? = 1, kC: number? = 1, kH: number? = 1): number Calculates the color difference of two Colors using CIEDE2000 , which can be used to compare the similarity (or difference) between colors. Smaller numbers correspond to greater similarity, while larger numbers correspond to less similarity. Color.luminance \u00b6 Color.luminance(color: Color): number Returns the relative luminance of the Color. Color.contrast \u00b6 Color.contrast(refColor: Color, testColor: Color): number Returns the contrast ratio between two Colors. Color.bestContrastingColor \u00b6 Color.bestContrastingColor(refColor: Color, ...: Color): (Color, number) Returns the Color with the highest contrast ratio to the reference color, along with the contrast ratio itself. Color.brighten \u00b6 Color.brighten(color: Color, amount: number? = 1): Color Brightens a Color by modifying its L* component. Color.darken \u00b6 Color.darken(color: Color, amount: number? = 1): Color Equivalent to Color.brighten(color, -amount) . Color.saturate \u00b6 Color.saturate(color: Color, amount: number? = 1): Color Saturates a Color by modifying its C* component. Color.desaturate \u00b6 Color.desaturate(color: Color, amount: number? = 1): Color Equivalent to Color.saturate(color, -amount) . Color.harmonies \u00b6 Color.harmonies(color: Color, harmony: string, analogyAngle: number? = 60): array<Color> Generates a list of Colors with a certain HSB harmony to the reference Color. The available harmonies are: Analogous , Complementary , SplitComplementary , Triadic , Tetradic (sometimes known as rectangle ), and Square . You may also specify an angle for the Analogous , SplitComplementary , and Tetradic harmonies. Math Operations \u00b6 Color == Color \u00b6 Comparing Colors with == returns whether their clipped RGB components are the same. print ( Color . new ( 0 , 0 , 0 ) == Color . new ( 0 , 0 , 0 )) --> true print ( Color . new ( 0 , 0 , 0 ) == Color . new ( 1 , 1 , 1 )) --> false print ( Color . new ( 1 , 1 , 1 ) == Color . new ( 2 , 2 , 2 )) --> true Color Types \u00b6 BrickColor \u00b6 color: BrickColor Color3 \u00b6 color: Color3 Hex \u00b6 hex: string The hex string can be in the format ABC or AABBCC , with or without a leading # . Number \u00b6 color: number [0, 16777215] RGB \u00b6 r: number [0, 255] g: number [0, 255] b: number [0, 255] HSB \u00b6 h: number [0, 360) or NaN s: number [0, 1] b: number [0, 1] For an explanation on HSB, you can read the Wikipedia article on it. HSV \u00b6 Alias for HSB HWB \u00b6 h: number [0, 360) or NaN w: number [0, 1] b: number [0, 1] For an explanation on HWB, you can read the Wikipedia article on it. HSL \u00b6 h: number [0, 360) or NaN s: number [0, 1] l: number [0, 1] For an explanation on HSL, you can read the Wikipedia article on it. CMYK \u00b6 c: number [0, 1] m: number [0, 1] y: number [0, 1] k: number [0, 1] For an explanation on CMYK, you can read the Wikipedia article on it. The RGB-CMYK conversions are naive and do not take color profiles into account. Temperature \u00b6 kelvin: number For best results, use temperatures in the range [1000, 40000]. The RGB-Temperature conversions are on based on Neil Bartlett's color-temperature . XYZ \u00b6 x: number [0, 1] (typical) y: number [0, 1] z: number [0, 1] (typical) For an explanation on XYZ, you can read the Wikipedia article on it. The RGB-XYZ conversions use illuminant D65 . xyY \u00b6 x: number [0, 1] y: number [0, 1] Y: number [0, 1] xyY is a color space related to XYZ . Lab \u00b6 l: number [0, 1] a: number [-1.28, 1.27] (typically) b: number [-1.28, 1.27] (typically) For an explanation on CIELAB, you can read the Wikipedia article on it. LChab \u00b6 l: number [0, 1] c: number [0, 1.50] (typically) h: number [0, 360) LCh(ab) is the cylindrical model of CIELAB . LCh \u00b6 Alias for LChab Luv \u00b6 l: number [0, 1] u: number [-1, 1] (typically) v: number [-1, 1] (typically) For an explanation on CIELUV, you can read the Wikipedia article on it. LChuv \u00b6 l: number [0, 1] c: number [0, 1.50] (typically) h: number [0, 360) LCh(uv) is the cylindrical model of CIELUV .","title":"Color"},{"location":"api/color/#constructors","text":"","title":"Constructors"},{"location":"api/color/#colornew","text":"Color.new(r: number, g: number, b: number): Color Standard Color constructor. Arguments should be in the range [0, 1], similar to Color3.new .","title":"Color.new"},{"location":"api/color/#colorrandom","text":"Color.random(): Color Creates a Color with random RGB components.","title":"Color.random"},{"location":"api/color/#colorgray","text":"Color.gray(scale: number): Color Creates an achromatic Color using the scale, which should be in the range [0, 1]. 0 corresponds to black, and 1 corresponds to white.","title":"Color.gray"},{"location":"api/color/#colornamed","text":"Color.named(name: string): Color Creates a Color based on a named CSS color . Names are case-insensitive.","title":"Color.named"},{"location":"api/color/#colorfrom","text":"Color.from(colorType: string, ...: any): Color Creates a Color from various color types. See the Color Types section for the list of available conversions and what arguments they require. Info You can also use an alternative constructor using Color.from[ColorType] (e.g. Color.fromColor3(...) instead of Color.from(\"Color3\", ...) ), except for the xyY color type.","title":"Color.from"},{"location":"api/color/#properties","text":"","title":"Properties"},{"location":"api/color/#colorr","text":"Color.R: number The clipped red RGB channel of the color, in the range [0, 1].","title":"Color.R"},{"location":"api/color/#colorg","text":"Color.G: number The clipped green RGB channel of the color, in the range [0, 1].","title":"Color.G"},{"location":"api/color/#colorb","text":"Color.B: number The clipped blue RGB channel of the color, in the range [0, 1].","title":"Color.B"},{"location":"api/color/#functions","text":"","title":"Functions"},{"location":"api/color/#colorisacolor","text":"Color.isAColor(color: any): boolean Returns whether the provided value is a Color. Checks if the value is a table with the following properties: The table is frozen The table has keys R , G , B , __r , __g , __b with numeric values The table has a to function","title":"Color.isAColor"},{"location":"api/color/#colorisclipped","text":"Color.isClipped(color: Color): boolean Returns whether the Color's RGB components are clipped. Some conversions (e.g. XYZ to sRGB) may result in RGB components outside of the range [0, 1]. In this case, the components will be clipped to the range [0, 1]. print ( Color . new ( 1 , 1 , 1 ): isClipped ()) --> false print ( Color . new ( 2 , 2 , 2 ): isClipped ()) --> true","title":"Color.isClipped"},{"location":"api/color/#colorunclippedeq","text":"Color.unclippedEq(refColor: Color, testColor: Color): boolean Compares the unclipped components of the Colors for equality. print ( Color . new ( 1 , 1 , 1 ) == Color . new ( 2 , 2 , 2 )) --> true print ( Color . new ( 1 , 1 , 1 ): unclippedEq ( Color . new ( 2 , 2 , 2 ))) --> false","title":"Color.unclippedEq"},{"location":"api/color/#colorcomponents","text":"Color.components(color: Color, unclipped: boolean? = false): (number, number, number) Returns the RGB components of the Color, either clipped or unclipped . You can also access the individual clipped components using Color.R , Color.G , and Color.B .","title":"Color.components"},{"location":"api/color/#colorto","text":"Color.to(color: Color, colorType: string): ...any Converts a Color to different formats. See the Color Types section for the list of available conversions and what values they output. Info You can also use an alternative converter using Color.to[ColorType] , e.g. Color:toColor3() instead of Color:to(\"Color3\") .","title":"Color.to"},{"location":"api/color/#colorinvert","text":"Color.invert(color: Color): Color Returns a Color with inverted RGB components.","title":"Color.invert"},{"location":"api/color/#colormix","text":"Color.mix(startColor: Color, endColor: Color, ratio: number, mode: string? = \"RGB\", hueAdjustment: string? = \"Shorter\"): Color Interpolates the start and end Colors in various color spaces. ratio should be in the range [0, 1]. Supported spaces are: RGB (default), CMYK , HSB (or HSV ), HWB , HSL , Lab , Luv , LChab (or LCh ), LChuv , xyY , and XYZ ( XYZ interpolation can be used for linear RGB interpolation). For color spaces with a hue component (e.g. HSB/L or LCh), there are different ways to interpolate the hue, and you can specify how it should be done by passing hueAdjustment : Shorter (default), Longer , Increasing , Decreasing , or Specified . These adjustments correspond to those specified in CSS Color Module Level 4 . Here are images of what the various interpolations look like, using red and aqua as example colors (with the default hue adjustment):","title":"Color.mix"},{"location":"api/color/#colorblend","text":"Color.blend(backgroundColor: Color, foregroundColor: Color, mode: string): Color Blends the background and foreground Colors in various modes. The available blending modes are: Normal , Multiply , Screen , Overlay , Darken , Lighten , ColorDodge , ColorBurn , HardLight , SoftLight , Difference , and Exclusion . The blending modes correspond to those specified in Compositing and Blending Level 1 .","title":"Color.blend"},{"location":"api/color/#colordeltae","text":"Color.deltaE(refColor: Color, testColor: Color, kL: number? = 1, kC: number? = 1, kH: number? = 1): number Calculates the color difference of two Colors using CIEDE2000 , which can be used to compare the similarity (or difference) between colors. Smaller numbers correspond to greater similarity, while larger numbers correspond to less similarity.","title":"Color.deltaE"},{"location":"api/color/#colorluminance","text":"Color.luminance(color: Color): number Returns the relative luminance of the Color.","title":"Color.luminance"},{"location":"api/color/#colorcontrast","text":"Color.contrast(refColor: Color, testColor: Color): number Returns the contrast ratio between two Colors.","title":"Color.contrast"},{"location":"api/color/#colorbestcontrastingcolor","text":"Color.bestContrastingColor(refColor: Color, ...: Color): (Color, number) Returns the Color with the highest contrast ratio to the reference color, along with the contrast ratio itself.","title":"Color.bestContrastingColor"},{"location":"api/color/#colorbrighten","text":"Color.brighten(color: Color, amount: number? = 1): Color Brightens a Color by modifying its L* component.","title":"Color.brighten"},{"location":"api/color/#colordarken","text":"Color.darken(color: Color, amount: number? = 1): Color Equivalent to Color.brighten(color, -amount) .","title":"Color.darken"},{"location":"api/color/#colorsaturate","text":"Color.saturate(color: Color, amount: number? = 1): Color Saturates a Color by modifying its C* component.","title":"Color.saturate"},{"location":"api/color/#colordesaturate","text":"Color.desaturate(color: Color, amount: number? = 1): Color Equivalent to Color.saturate(color, -amount) .","title":"Color.desaturate"},{"location":"api/color/#colorharmonies","text":"Color.harmonies(color: Color, harmony: string, analogyAngle: number? = 60): array<Color> Generates a list of Colors with a certain HSB harmony to the reference Color. The available harmonies are: Analogous , Complementary , SplitComplementary , Triadic , Tetradic (sometimes known as rectangle ), and Square . You may also specify an angle for the Analogous , SplitComplementary , and Tetradic harmonies.","title":"Color.harmonies"},{"location":"api/color/#math-operations","text":"","title":"Math Operations"},{"location":"api/color/#color-color","text":"Comparing Colors with == returns whether their clipped RGB components are the same. print ( Color . new ( 0 , 0 , 0 ) == Color . new ( 0 , 0 , 0 )) --> true print ( Color . new ( 0 , 0 , 0 ) == Color . new ( 1 , 1 , 1 )) --> false print ( Color . new ( 1 , 1 , 1 ) == Color . new ( 2 , 2 , 2 )) --> true","title":"Color == Color"},{"location":"api/color/#color-types","text":"","title":"Color Types"},{"location":"api/color/#brickcolor","text":"color: BrickColor","title":"BrickColor"},{"location":"api/color/#color3","text":"color: Color3","title":"Color3"},{"location":"api/color/#hex","text":"hex: string The hex string can be in the format ABC or AABBCC , with or without a leading # .","title":"Hex"},{"location":"api/color/#number","text":"color: number [0, 16777215]","title":"Number"},{"location":"api/color/#rgb","text":"r: number [0, 255] g: number [0, 255] b: number [0, 255]","title":"RGB"},{"location":"api/color/#hsb","text":"h: number [0, 360) or NaN s: number [0, 1] b: number [0, 1] For an explanation on HSB, you can read the Wikipedia article on it.","title":"HSB"},{"location":"api/color/#hsv","text":"Alias for HSB","title":"HSV"},{"location":"api/color/#hwb","text":"h: number [0, 360) or NaN w: number [0, 1] b: number [0, 1] For an explanation on HWB, you can read the Wikipedia article on it.","title":"HWB"},{"location":"api/color/#hsl","text":"h: number [0, 360) or NaN s: number [0, 1] l: number [0, 1] For an explanation on HSL, you can read the Wikipedia article on it.","title":"HSL"},{"location":"api/color/#cmyk","text":"c: number [0, 1] m: number [0, 1] y: number [0, 1] k: number [0, 1] For an explanation on CMYK, you can read the Wikipedia article on it. The RGB-CMYK conversions are naive and do not take color profiles into account.","title":"CMYK"},{"location":"api/color/#temperature","text":"kelvin: number For best results, use temperatures in the range [1000, 40000]. The RGB-Temperature conversions are on based on Neil Bartlett's color-temperature .","title":"Temperature"},{"location":"api/color/#xyz","text":"x: number [0, 1] (typical) y: number [0, 1] z: number [0, 1] (typical) For an explanation on XYZ, you can read the Wikipedia article on it. The RGB-XYZ conversions use illuminant D65 .","title":"XYZ"},{"location":"api/color/#xyy","text":"x: number [0, 1] y: number [0, 1] Y: number [0, 1] xyY is a color space related to XYZ .","title":"xyY"},{"location":"api/color/#lab","text":"l: number [0, 1] a: number [-1.28, 1.27] (typically) b: number [-1.28, 1.27] (typically) For an explanation on CIELAB, you can read the Wikipedia article on it.","title":"Lab"},{"location":"api/color/#lchab","text":"l: number [0, 1] c: number [0, 1.50] (typically) h: number [0, 360) LCh(ab) is the cylindrical model of CIELAB .","title":"LChab"},{"location":"api/color/#lch","text":"Alias for LChab","title":"LCh"},{"location":"api/color/#luv","text":"l: number [0, 1] u: number [-1, 1] (typically) v: number [-1, 1] (typically) For an explanation on CIELUV, you can read the Wikipedia article on it.","title":"Luv"},{"location":"api/color/#lchuv","text":"l: number [0, 1] c: number [0, 1.50] (typically) h: number [0, 360) LCh(uv) is the cylindrical model of CIELUV .","title":"LChuv"},{"location":"api/gradient/","text":"Types \u00b6 GradientKeypoint \u00b6 { Time: number, Color: Color } Time must be in the range [0, 1]. Constructors \u00b6 Gradient.new \u00b6 Gradient.new(keypoints: array<GradientKeypoint>): Gradient Standard Gradient constructor. The first keypoint must have a Time of 0, and the last keypoint must have a Time of 1. (Consequently, there must be at least 2 keypoints.) The keypoint list must be sorted by time. Gradient.fromColors \u00b6 Gradient.fromColors(...: Color): Gradient Creates a Gradient from one or more Colors. If one Color is passed, the start and end keypoints will have the same color. If two Colors are passed, the start and end keypoints will have the first and second color, respectively. If 3 or more Colors is passed, the keypoints will be equidistant with respect to time. Gradient.fromColorSequence \u00b6 Gradient.fromColorSequence(colorSequence: ColorSequence): Gradient Creates a Gradient from a ColorSequence . Properties \u00b6 Gradient.Keypoints \u00b6 Gradient.Keypoints: array<GradientKeypoint> Functions \u00b6 Gradient.invert \u00b6 Gradient.invert(gradient: Gradient): Gradient Returns a Gradient with reversed keypoints. Gradient.color \u00b6 Gradient.color(gradient: Gradient, time: number, mode: string? = \"RGB\", hueAdjustment: string? = \"Shorter\"): Color Returns a Color from the Gradient at the specified time, mixing mode, and hue adjustment (see Color.mix for what those are). time should be in the range [0, 1]. Gradient.colors \u00b6 Gradient.colors(gradient: Gradient, amount: number?, mode: string? = \"RGB\", hueAdjustment: string? = \"Shorter\"): array<Color> Returns an array of amount equidistant colors, using the specified mixing mode and hue adjustment (see Color.mix for what those are). Gradient.colorSequence \u00b6 Gradient.colorSequence(gradient: Gradient, steps: number? = 20, mode: string? = \"RGB\", hueAdjustment: string? = \"Shorter\"): ColorSequence Returns a ColorSequence with steps equidistant colors. If the mixing mode is RGB, the ColorSequence will instead consist of the colors from the GradientKeypoints used to construct it. Info Due to an engine limitation that only allows up to 20 keypoints in a ColorSequence, you may notice differences between the ColorSequence's intermediate colors and the Gradient's intermediate colors if you are using a mixing mode other than RGB. Math Operations \u00b6 Gradient == Gradient \u00b6 Comparing Gradients with == checks if they have the same number of keypoints, that the keypoints have the same Time values, and that the keypoints have the same Color values (using Color.unclippedEq ). local gradient1 = Gradient . fromColors ( Color . new ( 0 , 0 , 0 ), Color . new ( 1 , 1 , 1 ) ) local gradient2 = Gradient . new ({ { Time = 0 , Color = Color . new ( 0 , 0 , 0 )}, { Time = 1 , Color = Color . new ( 1 , 1 , 1 )} }) local gradient3 = Gradient . new ({ { Time = 0 , Color = Color . new ( 1 , 1 , 1 )}, { Time = 1 , Color = Color . new ( 0 , 0 , 0 )} }) print ( gradient1 == gradient2 ) --> true print ( gradient1 == gradient3 ) --> false print ( gradient1 == gradient3 : invert ()) --> true","title":"Gradient"},{"location":"api/gradient/#types","text":"","title":"Types"},{"location":"api/gradient/#gradientkeypoint","text":"{ Time: number, Color: Color } Time must be in the range [0, 1].","title":"GradientKeypoint"},{"location":"api/gradient/#constructors","text":"","title":"Constructors"},{"location":"api/gradient/#gradientnew","text":"Gradient.new(keypoints: array<GradientKeypoint>): Gradient Standard Gradient constructor. The first keypoint must have a Time of 0, and the last keypoint must have a Time of 1. (Consequently, there must be at least 2 keypoints.) The keypoint list must be sorted by time.","title":"Gradient.new"},{"location":"api/gradient/#gradientfromcolors","text":"Gradient.fromColors(...: Color): Gradient Creates a Gradient from one or more Colors. If one Color is passed, the start and end keypoints will have the same color. If two Colors are passed, the start and end keypoints will have the first and second color, respectively. If 3 or more Colors is passed, the keypoints will be equidistant with respect to time.","title":"Gradient.fromColors"},{"location":"api/gradient/#gradientfromcolorsequence","text":"Gradient.fromColorSequence(colorSequence: ColorSequence): Gradient Creates a Gradient from a ColorSequence .","title":"Gradient.fromColorSequence"},{"location":"api/gradient/#properties","text":"","title":"Properties"},{"location":"api/gradient/#gradientkeypoints","text":"Gradient.Keypoints: array<GradientKeypoint>","title":"Gradient.Keypoints"},{"location":"api/gradient/#functions","text":"","title":"Functions"},{"location":"api/gradient/#gradientinvert","text":"Gradient.invert(gradient: Gradient): Gradient Returns a Gradient with reversed keypoints.","title":"Gradient.invert"},{"location":"api/gradient/#gradientcolor","text":"Gradient.color(gradient: Gradient, time: number, mode: string? = \"RGB\", hueAdjustment: string? = \"Shorter\"): Color Returns a Color from the Gradient at the specified time, mixing mode, and hue adjustment (see Color.mix for what those are). time should be in the range [0, 1].","title":"Gradient.color"},{"location":"api/gradient/#gradientcolors","text":"Gradient.colors(gradient: Gradient, amount: number?, mode: string? = \"RGB\", hueAdjustment: string? = \"Shorter\"): array<Color> Returns an array of amount equidistant colors, using the specified mixing mode and hue adjustment (see Color.mix for what those are).","title":"Gradient.colors"},{"location":"api/gradient/#gradientcolorsequence","text":"Gradient.colorSequence(gradient: Gradient, steps: number? = 20, mode: string? = \"RGB\", hueAdjustment: string? = \"Shorter\"): ColorSequence Returns a ColorSequence with steps equidistant colors. If the mixing mode is RGB, the ColorSequence will instead consist of the colors from the GradientKeypoints used to construct it. Info Due to an engine limitation that only allows up to 20 keypoints in a ColorSequence, you may notice differences between the ColorSequence's intermediate colors and the Gradient's intermediate colors if you are using a mixing mode other than RGB.","title":"Gradient.colorSequence"},{"location":"api/gradient/#math-operations","text":"","title":"Math Operations"},{"location":"api/gradient/#gradient-gradient","text":"Comparing Gradients with == checks if they have the same number of keypoints, that the keypoints have the same Time values, and that the keypoints have the same Color values (using Color.unclippedEq ). local gradient1 = Gradient . fromColors ( Color . new ( 0 , 0 , 0 ), Color . new ( 1 , 1 , 1 ) ) local gradient2 = Gradient . new ({ { Time = 0 , Color = Color . new ( 0 , 0 , 0 )}, { Time = 1 , Color = Color . new ( 1 , 1 , 1 )} }) local gradient3 = Gradient . new ({ { Time = 0 , Color = Color . new ( 1 , 1 , 1 )}, { Time = 1 , Color = Color . new ( 0 , 0 , 0 )} }) print ( gradient1 == gradient2 ) --> true print ( gradient1 == gradient3 ) --> false print ( gradient1 == gradient3 : invert ()) --> true","title":"Gradient == Gradient"}]}